---
layout: note
title: C++ tips for blueprints
categories: [article]
dateWritten: 15 Feb 2025
engineVersionWritten: UE 5.5.3
toc: true
---

<h2 class="heading2" id="introduction">Introduction</h2>
<hr class="heading-divider">

<p class="paragraph paragraph-spacer">
    Blueprints are integral to many workflows in Unreal Engine, making interfacing between native and blueprints code a core skill to grow as a developerâ€”especially when working in a team. This page lists tips and tricks I've found the most useful over the years, I hope they prove useful to you as well!
</p>

<h2 class="heading2" id="metadata-specifiers">Metadata specifiers</h2>
<hr class="heading-divider">

<p class="paragraph paragraph-spacer">
    Metadata specifiers can be applied to classes, structs, enums (and their values), functions, and properties. I will highlight a small handful of these below, though I highly recommend taking a look at the full list in the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/metadata-specifiers-in-unreal-engine" class="text-link">official documentation on metadata specifiers</a>.
</p>

<h3 class="heading3" id="blueprint-protected">Blueprint protected</h3>

<p class="paragraph">
    Blueprints are full of unpleasant surprises for programmers. One of these surprises is that the <span class="code-inline">protected</span> access specifier is not honored automatically. You can fix it by using the <span class="code-inline">BlueprintProtected</span> metadata specifier for every protected <span class="code-inline">UFUNCTION</span> or <span class="code-inline">UPROPERTY</span> intended to be used in blueprints, like so:
</p>

<div class="code-block scrollbar">
    <code class="grow">
    {% highlight cpp linenos %}
    protected:
        UFUNCTION(BlueprintCallable, meta = (BlueprintProtected))
	    void MyProtectedFunction();

	    UPROPERTY(BlueprintReadWrite, meta = (BlueprintProtected))
	    int32 MyProtectedInt{ INDEX_NONE };    {% endhighlight %} 
    </code>
</div>

<p class="paragraph paragraph-spacer">
    Frustratingly, if "public" nodes accessing these protected members already exist in blueprints before the metadata specifier is added, those blueprints will continue compiling and running just fine and not log any errors when gleefully executing code they should not have access to.
</p>

<h3 class="heading3" id="determines-output-type">Determines output type</h3>

<p class="paragraph">
    Creating true wildcard pins in blueprint nodes is, unfortunately, not trivial. However, the <span class="code-inline">DeterminesOutputType</span> metadata specifier covers some of the cases. Here's how to use it:
</p>

<div class="code-block scrollbar">
    <code class="grow">
    {% highlight cpp linenos %}
    UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "ActorClass"))
    static AActor* FindActorByClass(TSubclassOf<class AActor> ActorClass);    {% endhighlight %} 
    </code>
</div>

<p class="paragraph paragraph-divider">
    The above code will create the following nodes. Notice how the <span class="code-inline">ActorClass</span> input determines the type of the output:
</p>

<img class="illustration paragraph-spacer" src="{{ "/assets/images/blueprint/find-actor-by-class.png" | relative_url }}">

<h3 class="heading3" id="display-priority">Display priority</h3>

<p class="paragraph paragraph-spacer">text here</p>

<h3 class="heading3" id="world-context">World context</h3>

<p class="paragraph paragraph-spacer">text here</p>