---
layout: note
title: The curious case of AActor function execution order
description: Why you can't override native BeginPlay() implementation in blueprints and why your code may appear to run out of order.
categories: [article]
openGraphImage: "https://agneskripkaite.github.io/assets/images/opengraph/beginPlay.png"
dateWritten: 15 Feb 2025
engineVersionWritten: UE 5.5.3
dateEdited: 15 Mar 2025
toc: true
---

<h2 class="heading2" id="introduction">Introduction</h2>
<hr class="heading-divider">

<p class="paragraph paragraph-spacer">
    Overriding functions and calling their parent implementations are such fundamental concepts in inheritance that we hardly ever even think about them twice. And we definitely never anticipate any strange behavior!
</p>

<p class="paragraph pb-2">
    Let's take a simple example: create a C++ <span class="code-inline">Actor</span> class and then inherit a blueprint class from it. Say, we override the <span class="code-inline">BeginPlay()</span> function in C++ to do something. And in the blueprint we may implement something like this:
</p>
<img class="illustration paragraph-spacer" src="{{ "/assets/images/blueprint/begin-play-execution-order.png" | relative_url }}">
<p class="paragraph">
    Any reasonable developer would expect the execution order to be <span class="code-inline">First thing → Parent implementation → Second thing</span>. However, the actual execution order will most likely be <span class="code-inline">First thing → Second thing → Parent implementation</span> (though it could also be <span class="code-inline">Parent implementation → First thing → Second thing</span>). Or, if you forgot the call to <span class="code-inline">Super::BeginPlay()</span> in your native class, neither First thing nor Second thing would be executed. If you don't believe me, try it!
</p>

<h2 class="heading2 heading-spacer" id="begin-play-is-not-begin-play">BeginPlay() is... not BeginPlay()?!</h2>
<hr class="heading-divider">

<p class="paragraph paragraph-spacer">
    The key is that the <span class="code-inline">BeginPlay()</span> in blueprints is actually not an override of <span class="code-inline">BeginPlay()</span> in native!
</p>
<p class="paragraph">
    One way to see this for yourself is to observe that the <span class="code-inline">BeginPlay()</span> function in the native <span class="code-inline">Actor</span> class has the following comment above it:
</p>
<div class="code-block scrollbar">
    <code class="grow">
    {% highlight cpp linenos %}
    // Called when the game starts or when spawned
    virtual void BeginPlay() override;    {% endhighlight %} 
    </code>
</div>
<p class="paragraph pb-2">
    However, in the child blueprint class of this actor, the <span class="code-inline">BeginPlay()</span> node has a similar but different tooltip:
</p>
<img class="illustration paragraph-spacer" src="{{ "/assets/images/blueprint/begin-play-tooltip.png" | relative_url }}">

<p class="paragraph">
    Where does this text come from? Through the wonders of modern technology we can search the tool tip text in our IDE of choice and find out that the function in blueprints is actually <span class="code-inline">ReceiveBeginPlay()</span> defined in <span class="code-inline">Actor.h</span>:
</p>
<div class="code-block scrollbar paragraph-spacer">
    <code class="grow">
    {% highlight cpp linenos %}
    /** Event when play begins for this actor. */
    UFUNCTION(BlueprintImplementableEvent, meta=(DisplayName = "BeginPlay"))
    ENGINE_API void ReceiveBeginPlay();    {% endhighlight %} 
    </code>
</div>

<p class="paragraph">
    This function is called inside the normal <span class="code-inline">AActor::BeginPlay()</span> just before setting the actor as <span class="code-inline">HasBegunPlay</span>:
</p>
<div class="paragraph-spacer">
<div class="code-block scrollbar">
    <code class="grow">
    {% highlight cpp linenos %}
    ReceiveBeginPlay();
    ActorHasBegunPlay = EActorBeginPlayState::HasBegunPlay;    {% endhighlight %} 
    </code>
</div>    
</div>

<h2 class="heading2 heading-spacer" id="what-this-means-in-practice">What this means in practice</h2>
<hr class="heading-divider">

<p class="paragraph paragraph-spacer">
    At first glance one would expect the blueprint implementation of <span class="code-inline">BeginPlay()</span> to override the native parent implementation. However, we now know that is impossible as they are two different functions. If your design requires a way to override native functionality you will have to create a custom function and use that in blueprints instead.
</p>

<p class="paragraph">
    This also means that one can control the order in which the code is executed by being mindful of where the call to super is placed in the native implementation. To illustrate this point, the following code
</p>
<div class="code-block scrollbar">
    <code class="grow">
    {% highlight cpp linenos %}
    void AWActor::BeginPlay()
    {
        UE_LOG(LogTemp, Log, TEXT("%s() in native before Super::BeginPlay()!"),
            ANSI_TO_TCHAR(__FUNCTION__));

        Super::BeginPlay();

        UE_LOG(LogTemp, Log, TEXT("%s() in native after Super::BeginPlay()!"),
            ANSI_TO_TCHAR(__FUNCTION__));
    }    {% endhighlight %} 
    </code>
</div>
<p class="paragraph">
    with a print string on <span class="code-inline">BeginPlay()</span> in a child blueprint yields the following log output:
</p>
<div class="code-block scrollbar">
    <code class="grow">
    {% highlight plaintext linenos %}
    LogTemp: AWActor::BeginPlay() in native before Super::BeginPlay()!
    LogBlueprintUserMessages: [B_WActor_C_UAID_7085C2B5FE9B684C02_1813221055] Event BeginPlay in blueprint  
    LogTemp: AWActor::BeginPlay() in native after Super::BeginPlay()!    {% endhighlight %} 
    </code>
</div>

<p class="paragraph paragraph-spacer">
    Note that without the call to super, the blueprint function will not execute at all!
</p>

<p class="paragraph pb-3">
    Finally, you can still add a call to parent by right-clicking the event in blueprints and selecting <span class="code-inline">Add Call to Parent Function</span>; however, if the blueprint is a direct child of a native parent this call will do nothing as there is no parent implementation. If you inherit another blueprint class from the first one, you will see the call to parent is added automatically, since <span class="code-inline">ReceiveBeginPlay()</span> can now be meaningfully overriden. But again, note that you will only be overriding the parent blueprint behavior, and none of the native parent behavior.

<h2 class="heading2 heading-spacer" id="list-of-functions">List of functions with similar behavior</h2>
<hr class="heading-divider">

<p class="paragraph pb-3">
    Above, I only talk about <span class="code-inline">BeginPlay()</span> to keep the explanation simpler. However, it isn't the only <span class="code-inline">Actor</span> function likely to cause headaches and bugs if one doesn't anticipate the blueprint and native functions to not match up. Here's a (hopefully) complete list of these rascals:
</p>

<ul class="list-disc ml-7 paragraph-spacer">
    <li><span class="code-inline">BeginPlay()</span> → <span class="code-inline">ReceiveBeginPlay()</span></li>
    <li><span class="code-inline">EndPlay()</span> → <span class="code-inline">ReceiveEndPlay()</span></li>
    <li><span class="code-inline">Tick()</span> → <span class="code-inline">ReceiveTick()</span></li>
    <li><span class="code-inline">Destroyed()</span> → <span class="code-inline">ReceiveDestroyed()</span></li>
</ul>

<p class="paragraph paragraph-spacer">
    If you comb through <span class="code-inline">Actor.h</span> you will notice over a dozen other <span class="code-inline">BlueprintImplementableEvent</span> functions that start with "Receive" and have user-facing names without it. However, they don't trick programmers into the same trap as their C++ counterparts also have different names.
</p>

<p class="paragraph paragraph-spacer">
    PS I haven't checked it for sure, but I suspect this article is also relevant for some functions in <span class="code-inline">ActorComponent</span> as well, notably <span class="code-inline">BeginPlay()</span> and <span class="code-inline">EndPlay()</span>.
</p>